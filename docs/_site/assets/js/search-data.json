{"0": {
    "doc": "Backend",
    "title": "Backend",
    "content": "The backend is comprised of a variety of systems and technologies. The application is a REST API created using Express.js that communicates with services such as a MongoDB for data storage, stripe for payments, and AWS (Amazon Web Services) Simple Email Service (SES)for sending dynamic emails to users. Additionally, Redis is used to hold session data to and to perform asynchronous tasks on the server side. The following will expand on the require skill set to use each of these technologies. ",
    "url": "/pages/Onboarding/Backend.html",
    
    "relUrl": "/pages/Onboarding/Backend.html"
  },"1": {
    "doc": "Backend",
    "title": "Table of contents",
    "content": ". | Backend . | | Express.js . | To Get a solid understanding of Express.js and its inner workings watch the following videos | Middlewares | Routes &amp; Routers | Controllers | Services | . | Redis . | Bull | Subscribers | . | MongoDB . | Mongoose | Models &amp; Schemas | . | AWS SES | Stripe | . | . ",
    "url": "/pages/Onboarding/Backend.html#table-of-contents",
    
    "relUrl": "/pages/Onboarding/Backend.html#table-of-contents"
  },"2": {
    "doc": "Backend",
    "title": "Express.js",
    "content": "To Get a solid understanding of Express.js and its inner workings watch the following videos . | 35 Minute Express.js Tutorial | REST API Explainer Video through Express.js | Middleware Explainer Video | . Express.js is a Node.js framework that allows users to create a “REST API”. This means that the backend API will respond to HTTP requests such as GET, POST, EDIT, DELETE to specific routes such as /users, /info, /announcement/create, ... Middlewares . When a request is sent to a specific route it needs to be properly processed until the server can identify what the request is asking for to then provide it with the correct response or in the case of an invalid request, an error. The processing of the data is done through middlewares. These are functions that take the request data and modify it in specific ways so that a response can be formed. Some middlewares are pre-made and can be used installed through Node.js packages, for example, the bodyParser middleware is a package that takes the request data and parses the body of the request or the data that was sent along with it and places it into a JSON object. However you can also create your own middlewares, any function that takes in (request, response, next) as arguments can be a middleware. These functions will execute some code and either modify the request object and then call next() which will then pass that information to the next middleware. The request object continues to get modified by different middlewares until the final middleware terminates the request by changing the status() of the response object, The final middleware can also send along data or information back to the user by using send(). Example middleware and usage: . /** * Checks whether the user is signed in. * @param {Object} req * @param {Object} res * @param {Function} next * @return {*} */ const checkLoggedIn = (req, res, next) =&gt; { if (req.isAuthenticated()) { return next(); } else { return res .status(403) .send({ message: \"Please sign in to access this route!\" }); } }; app.get(\"/\", checkLoggedIn, otherMiddleware, finalMiddleware); . You can see how in the above message the response is a 403 error if the user is not logged in. However, if the user is logged in the next() function is called to send the data to the next middleware. Routes &amp; Routers . Each set of routes get their own router file. Inside each router file a specific route and HTTP request type are mapped to a certain service. To make the codebase more dynamic the connection between the routes and the services are expanded to go through a controller. Example router: . const express = require(\"express\"); const { getTimeline } = require(\"../controllers/TimelineController\"); const router = express.Router(); /** * @swagger * /timeline: * get: * summary: Get all the timeline events * responses: * '200': * description: Successfully retrieved the timeline events * content: * application/json: * schema: * type: object * properties: * timelines: * type: array * items: * $ref: '#components/schemas/Timeline' */ router.get(\"/\", getTimeline); app.use(\"/timeline\", router); . Controllers . Controllers are specific middlewares used to perform some processing on the HTTP requests before they are sent to services. In the above example, getTimeline is one middleware from the timeline controller. Example controller: . const AnnouncementServices = require(\"../services/AnnouncementServices\"); const AnnouncementController = { /** * Gets all announcements */ async getAnnouncement(req, res, next) { try { const allAnnouncements = await AnnouncementServices.getAllAnnouncements(); return res.status(200).send({ announcements: allAnnouncements }); } catch (e) { next(e); } }, /** * Gets all completed announcements of a user */ async getCompletedAnnouncements(req, res, next) { const currentUser = req.user; try { const completedAnnouncements = await AnnouncementServices.getCompletedAnnouncements(currentUser); return res.status(200).send({ announcements: completedAnnouncements }); } catch (e) { next(e); } }, async otherMiddleware (req, res, next) {...}, }; module.exports = AnnouncementController; . Services . Each service gets one or more file which directly works with the particular technology. However, although MongoDB is one service the majority of the service files use it since different parts of the website have their own section of the database. Each service file contains functions that communicate with their service without any interaction with the HTTP request. The functions return key pieces of information that was received from the service back to the controller. Example service file: . const SES = new SESv2Client({ region: \"ca-central-1\" }); const EmailServices = { /** * Create and save an email template * @param {String} templateName name of the new template * @param {String} html html body * @param {String} subject subject of the email * @param {String} text text body * @see {@link https://aws.amazon.com/blogs/messaging-and-targeting/introducing-email-templates-and-bulk-sending/} for the filling of `html` and `text` * @returns {Promise} promise */ async createTemplate(templateName, html, subject, text) { const params = { TemplateContent: { Html: html, Subject: subject, Text: text, }, TemplateName: templateName, }; const command = new CreateEmailTemplateCommand(params); return SES.send(command); }, /** * Send bulk personalized template emails * @param {Object[]} bulkEmailEntries an array containing arrays of email addresses * @param {String} templateName name of template used * @param {Object} defaultTemplateData defult data to be filled in the template * @param {String} fromAddress the email adress the email is being sent from * @returns {Promise} promise */ async sendBulkTemplateEmail( bulkEmailEntries, templateName, defaultTemplateData, fromAddress ) { const params = { BulkEmailEntries: bulkEmailEntries.map((entry) =&gt; { return { Destination: { ToAddresses: [...entry], }, }; }), DefaultContent: { Template: { TemplateData: JSON.stringify(defaultTemplateData), TemplateName: templateName, }, }, FromEmailAddress: fromAddress, }; const command = new SendBulkEmailCommand(params); return SES.send(command); }, }; module.exports = EmailServices; . ",
    "url": "/pages/Onboarding/Backend.html#expressjs",
    
    "relUrl": "/pages/Onboarding/Backend.html#expressjs"
  },"3": {
    "doc": "Backend",
    "title": "Redis",
    "content": "Redis is a tool used to keep data in memory. This makes retrieving this data very fast as opposed to making a call to a database. However we use Redis on the backend to hold the information of subscriptions that run in the background without effecting other functions. This is done by creating a Queue with Bull which is a list of jobs that need to be done in the order that they were added or FIFO (First In, First Out) order. Bull . Bull is a Node.js package that allows you to create a Queue and store that Queue inside your Redis datastore. This makes the process a lot faster than storing the Queue information in the database . Subscribers . Subscribers are jobs that are added to the Bull Queues to be done. They are separated based on services or parts of the website. Example subscriber file: . const Queue = require(\"bull\"); const EmailServices = require(\"../services/EmailServices\"); const UserServices = require(\"../services/UserServices\"); const announcementSubscription = new Queue(\"newFrosh\", { redis: { port: process.env.REDIS_PORT, host: \"redis\", password: process.env.REDIS_PASSWORD, }, }); announcementSubscription.process((job, done) =&gt; { console.log(\"Announcement Created!\"); if (job.data.unsubed === true) { try { const result = EmailServices.sendTemplateEmail( {}, \"unsubscribed\", [job.data.email], \"tech@orientation.skule.ca\" ); result.then((response) =&gt; { console.log(response); done(); }); } catch (error) { done(error); } } else { try { const bulkEmailEntries = []; UserServices.getAllUsers().then((users) =&gt; { let count = 0; let entries = []; users.forEach((user) =&gt; { if (user.canEmail === true) { count++; entries.push(user.email); if (count === 20) { bulkEmailEntries.push(entries); count = 0; entries = []; } } }); if (entries.length &gt; 0) { bulkEmailEntries.push(entries); } const result = EmailServices.sendBulkTemplateEmail( bulkEmailEntries, \"announcement\", { name: job.data.name, description: job.data.description }, \"tech@orientation.skule.ca\" ); result.then((response) =&gt; { console.log(\"response:\"); console.log(response); done(); }); }); } catch (error) { done(error); } } }); module.exports = announcementSubscription; . This file sends a mass email to all F!rosh for inform them of an announcement or send someone an email letting them know they have unsubscribed from announcement emails. ",
    "url": "/pages/Onboarding/Backend.html#redis",
    
    "relUrl": "/pages/Onboarding/Backend.html#redis"
  },"4": {
    "doc": "Backend",
    "title": "MongoDB",
    "content": "MongoDB is a noSQL database that we use to store F!rosh data. Watch these videos: . | MongoDB Crash Course | Mongoose Crash Course | . Mongoose . Mongoose is a wrapper for MongoDB that makes interacting with the database a lot more streamlines and easier. Models &amp; Schemas . You can use Mongoose Schemes to create data models that the database will follow when new piece of data are added. ",
    "url": "/pages/Onboarding/Backend.html#mongodb",
    
    "relUrl": "/pages/Onboarding/Backend.html#mongodb"
  },"5": {
    "doc": "Backend",
    "title": "AWS SES",
    "content": "The AWS SES is an API used to send emails from the backend programmatically. ",
    "url": "/pages/Onboarding/Backend.html#aws-ses",
    
    "relUrl": "/pages/Onboarding/Backend.html#aws-ses"
  },"6": {
    "doc": "Backend",
    "title": "Stripe",
    "content": "Stripe is the API we use to process payments F!rosh make to pay for F!rosh Week and F!rosh retreat. ",
    "url": "/pages/Onboarding/Backend.html#stripe",
    
    "relUrl": "/pages/Onboarding/Backend.html#stripe"
  },"7": {
    "doc": "Backend",
    "title": "Backend",
    "content": "The backend is meticulously organized under the server folder in their respective subfolders. controllers, loaders, middlewares, models, routes etc. The general hierarchy is as follows: routes -&gt; middlewares -&gt; controller -&gt; services -&gt; logic here for a route . ",
    "url": "/pages/Project%20Architecture/Backend.html",
    
    "relUrl": "/pages/Project%20Architecture/Backend.html"
  },"8": {
    "doc": "Docker",
    "title": "Docker",
    "content": "We use Docker to run our application and to deploy it to our hosting platform. You can basically imagine Docker as a way to ensure that everyone who is running the code has a single standard environment. You can watch these videos to get a better idea: . | Docker Tutorial . | Docker Compose Tutorial . | . ",
    "url": "/pages/Onboarding/Docker.html",
    
    "relUrl": "/pages/Onboarding/Docker.html"
  },"9": {
    "doc": "Documentation",
    "title": "Documentation",
    "content": "For this project you will be expected to develop documentation for your code. This is done in two parts, the first is in code comments such as line commends and function docstrings, the second one is the thing you are reading right now. We will ask you to contribute to these documents as you develop code for the project. The full nature of which we will explain during our meetings. The following is a guideline on how to contribute to the documentation. ",
    "url": "/pages/Onboarding/Documentation.html",
    
    "relUrl": "/pages/Onboarding/Documentation.html"
  },"10": {
    "doc": "Documentation",
    "title": "Adding to this website",
    "content": "This website is a Jekyll website that is auto generated based on markdown files which is running the Just the Docs theme. To add a new page you just create a file with the .md extension for markdown inside the /docs/pages folder. To learn more about adding content read this. ",
    "url": "/pages/Onboarding/Documentation.html#adding-to-this-website",
    
    "relUrl": "/pages/Onboarding/Documentation.html#adding-to-this-website"
  },"11": {
    "doc": "Frontend",
    "title": "Frontend",
    "content": "💻 Hello, and welcome to a beginner’s guide to frontend web development! 💻 . This guide is here to help you get started with frontend development in React and is meant to be an iterative and dynamic guide, so you are encouraged to add any resources you found helpful as well. For those that don’t know, . “… frontend is a term used to describe the client side of a website or application. It involves creating the user interface (UI) and functionality that users interact with” . Frontend development involves using a combination of HTML, scss, and JavaScript. HTML (Hypertext Markup Language) is used to structure the content of a web page, for example, all the text and images on a website are embedded in HTML tags. scss (Cascading Style Sheets) is used to style and change the layout of the pages, for example changing the colours of components and centring items. Finally, JavaScript is used to add functionality to the page and make it interactive for the users, this includes things like clicking buttons. React is a JavaScript framework that allows you to build user interfaces in a very modular way using components. We kinda describe components like building blocks hence the modularity. They can be nested inside each other allowing you to easily build more complex components by combining smaller ones. For example, an entire page is a component made up of smaller components like text boxes, buttons, images, etc. Note that the file extension for React is .jsx, just something to be careful of when creating new files! . A framework is like a set of tools that you can use to build applications that make it easier for you to maintain and update your applications (overall making your life easier)! . ",
    "url": "/pages/Onboarding/Frontend.html",
    
    "relUrl": "/pages/Onboarding/Frontend.html"
  },"12": {
    "doc": "Frontend",
    "title": "Table of contents",
    "content": ". | Frontend . | React Functional Components . | Function Keyword | Arrow Function | . | Writing Your First Component . | Importing . | Importing Images | Importing Components | Exporting Components | . | Important HTML Notes . | Multiple Classes | Conditional Classes | Multiple &amp; Conditional Classes | Alternative Style Attribute | . | Important Scss Notes . | Apply Style to Multiple Components | Apply to All Components | Apply Style to All Tags | . | PropTypes | Handling Events | useState and useEffect . | useState | useEffect | . | Debugging the Frontend . | Disclaimer | . | . | . | . ",
    "url": "/pages/Onboarding/Frontend.html#table-of-contents",
    
    "relUrl": "/pages/Onboarding/Frontend.html#table-of-contents"
  },"13": {
    "doc": "Frontend",
    "title": "React Functional Components",
    "content": "There are two ways you can write components in React, functional and class components. For the orientation website, we write everything in functional components because it’s a lot simpler and easier to understand! . Conceptually, components are like JavaScript functions. They accept inputs (called “props” short for properties) and return React elements (HTML) describing what should appear on the screen. There are multiple ways that you can write functional components as well, . There are multiple ways that you can write functional components as well, . Function Keyword . function MyComponent(prop1, prop2) { return ( &lt;&gt; &lt;h1&gt;{prop1}&lt;/h1&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;/&gt; ) } . Arrow Function . const MyComponent = ({prop1, prop2}) =&gt; { return ( &lt;&gt; &lt;h1&gt;{prop1}&lt;/h1&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;/&gt; ) } . When naming components make sure to use Pascal Case, e.g., FirstName and LastName! . ",
    "url": "/pages/Onboarding/Frontend.html#react-functional-components",
    
    "relUrl": "/pages/Onboarding/Frontend.html#react-functional-components"
  },"14": {
    "doc": "Frontend",
    "title": "Writing Your First Component",
    "content": "Importing . import React, { useState, useEffect, useContext } from 'react'; import PropTypes from 'prop-types'; import './yourFile.scss'; . These three lines are pretty important! . | useState, useEffect and useContext are built-in functions in React, we typically use useState and useEffect which will be discussed further in a later section. | . Instead of useContext, we use Redux, which allows us to pass and update states across multiple components. No worries if this concept of “State” is unclear, it will be described later! . | Secondly, PropTypes allows for built-in type checking when you pass in any props to your component. | Lastly, make sure to import your .scss file! Scss includes all the features of scss but has more features. You can treat your Scss file as a regular scss file. | . In addition to those three important lines, you might also need to import images or components! . Importing Images . import ImageName from './filepath' . ImageName is a name that you declare yourself, you will use this name to “call” or “instantiate” the image. Importing Components . import { Component1, Component2 } from './filepath' import { Component3, Component4 } from 'package-name' . To import a component from another .jsx file, you’ll need to make sure to export the component. For components that are declared and used in the same file, there is no need to import them. More later! . Packages are like components made by other people that you can use! Packages must be installed first using npm or yarn. Exporting Components . To use components that you’ve built from other files, you must export the component! . Note, you can export multiple components from one file as well! . There are two syntaxes for exporting your components, you can add export before the const keyword, or you can export all the components at the end of your code (we recommend this!). export const MyComponent = () =&gt; { return () } . const Component1 = () =&gt; { return () } const Component2 = () =&gt; { return () } export { Component1, Component2 } . Important HTML Notes . Some of the most important tags you’ll need to know are, &lt;div&gt;, &lt;h1&gt; to &lt;h6&gt;, &lt;p&gt;, and sometimes &lt;span&gt;. &lt;div&gt; tags define a section of the document, and we would recommend using them for pretty much anything you need! . React syntax is slightly different than HTML, so here is the general format of any tag, . &lt;div className=\"class-name\" style=&gt; {children} &lt;/div&gt; &lt;img className=\"class-img\" src={ImportedImage}&gt;&lt;/img&gt; . We refer to anything inside the tag, this can be plain text, other tags or components as the children. You can add classes using className to specify multiple styles, these classes are imported from your Scss file, or you can add style similar to an object. Multiple Classes . &lt;div className=\"class1 class2\"&gt;&lt;/div&gt; . Conditional Classes . &lt;div className={ condition ? \"class1\" : \"\"}&gt; &lt;/div&gt; . In words, it means, if the condition is true, it will apply the style from class1, if the condition is false, it will not apply any style (hence the empty string) . Multiple &amp; Conditional Classes . &lt;tag className={` class ${ condition ? 'true-class' : 'false-class'} `}&gt;&lt;/tag&gt; . We recommend getting really familiar with the conditional (ternary) operator! . condition ? ifTrue : ifFalse . Alternative Style Attribute . // define your style object const styleTag = { display: 'flex', color: 'red' } &lt;div style={styleTag} /&gt; . Generally, all the tags that you use in HTML can be used in React. Important Scss Notes . Once again Scss, works the exact same way as scss. We keep all the style code in another file and import it to our .jsx file. When you’re writing your style code, here are some important styles you should keep in mind as well as general syntax! .class-name { /* these three lines below aligns the contents to the center of a container */ display: flex; justify-content: center; align-items: center; background-color: green; transition: background-color 200ms; /* the ampersand means that you’re applying the style to the current component */ &amp;:hover { /* just like it sounds, this style “actives” when you hover over with your mouse */ background-color: red; transition: background-color 200ms; } &amp;:active { /* this style actives when you press and hold */ background-color: blue; transition background-color 200ms; } } . Apply Style to Multiple Components .class-one, .class-two { &amp;:hover{} &amp;:active{} } . Apply to All Components . * {} . Apply Style to All Tags . h1, h2, div {} . You might also notice that :root, uses two dashes --. These are style variables that we assign in scss. They can be used for color to make sure everything follows the same style guide or transitions! . :root { --purple: #AA98A9; /* we define the variable purple with a certain HEX code */ } .class-name { color: var(--purple) } . PropTypes . The package that we use for props is slightly annoying because the capitalization of certain characters is very particular and easy to mess up (or maybe it’s just me). So make sure to follow this! . import PropTypes from 'prop-types'; . Lets take a look at an example now! . const propTypesObj = { propBool: PropTypes.bool, propString: PropTypes.string, propObject: PropTypes.object, children: PropTypes.node, }; const defaultProps = { propBool: true, propString: \"default string\", }; Component.propTypes = propTypes; Component.defaultProps = defaultProps; . Here, we are creating an object called propTypesObj, with the following properties, propBool, propString, propObject, and children. Whenever we create props, we need to identify the type, for example propBool will be a bool, etc. PropTypes.object is typically used for creating props that allow you to add in style for example the style object mentioned above. The property children with PropTypes.node is what we use for components that have children, i.e., components that are nested inside other components. For example, . const Component = ({children}) =&gt; { return( &lt;div&gt;{children}&lt;/div&gt; ) } . You can name your props, however, you would like, just make sure that the naming is logical for anyone that wants to use the component! . Next, you can also assign default props, when the user doesn’t provide a prop! So if you’re calling MyComponent in another file . export const MyComponent = ({propBool, propString, propObject, children}) =&gt; { return( &lt;div style={propObject}&gt; &lt;h1&gt;{propString}&lt;/h1&gt; {children} { propBool ? (&lt;p&gt;{propString}&lt;/p&gt;) : (&lt;&gt;&lt;/&gt;) } &lt;/div&gt; ) } . export const ParentComponent = () =&gt; { return ( &lt;div&gt; &lt;MyComponent propString='Example' &gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;/MyComponent&gt; &lt;div&gt; ) } . Note that the line &lt;h1&gt;Hello&lt;/h1&gt; is the children prop! . In this example above, due to defaultProps, although propBool isn’t stated, it will automatically be assigned the value true. Let us know how we can help and improve this section! Feel free to check out the link here as well, we mentioned the main propTypes you’ll need but there are others that you can look into! . Handling Events . One important aspect of any component is something called handling events. These events involve responding to user interactions like clicks, keyboard inputs, etc. One event handler that you might be familiar with is the onClick (in HTML, onclick). In React, you can pass a function as the event handler. These event handlers are written inside the HTML or component tag. &lt;Component onClick={ () =&gt; { console.log(\"click\") } } /&gt; . Alternatively, you can declare the function separately, and pass it into the component, . const function = () =&gt; { console.log(\"click\") } &lt;Component onClick={ function }/&gt; . Here are some more examples for reference! . useState and useEffect . State and Effect are two really important features to learn when using React – once you have these two mastered, you’re pretty much good to go! . useState . State(s) are like properties of the component that can be updated with user interactions. Similar to a light switch that has an on state and an off state. A component can have multiple states, and these states can change as a response to user interactions or other system-generated events, and these changes can change the behaviour of a component (for example changing the appearance of the component or page, limiting or enabling ways that the user can interact, etc.). We can take a look at a simple component generated with the help of ChatGPT 😉, . import React, { useState } from 'react'; export const Button = () =&gt; { const [count, setCount] = useState(0); const [click, setClick] = useState(false); const clickFunction = () =&gt; { setCount(count + 1); setClick(!click); console.log(\"click?\", click); } return ( &lt;div onClick={ clickFunction }&gt; You clicked me {count} times! &lt;/div&gt; ); } . Lets walk through the code snippet starting with initializing your state variables. Here is the general syntax, . const [state, setState] = useState(); . | state is the name of your state variable, | setState is a function that can changes your state variable, as observed in the code above, . | setCount increments count by 1, | setClick sets click to the opposite value. | . | And finally, useState is used to set the initial value of the state, as shown above, we can see that, . | count is initially set to | click is initially set to false. | . | . You can kinda think of setState like this, . setState(newState) → state = newState . Using the event handler we introduced previously, we see that when the user clicks the component, the code executes the clickFunction, which changes the state variables. The most important note to keep in mind is that everytime the state changes, we’re technically rendering a new component. useEffect . UseEffect is like a function that runs on every render. This could be when you first render a page, or when state variables change and render the components. Here is the general syntax of useEffect, . useEffect(() =&gt; { // this runs on every render // no dependencies }); . We can specify how we want useEffect to run using a dependency array. The dependency array can be empty, or contain multiple values. useEffect(() =&gt; { // this runs on the first render (i.e., rendering the page) // empty dependency array }, []); . useEffect(() =&gt; { // this runs on the first render and runs everytime the any of the dependency values change }, [ state, props]); . Typically, we can pass state variables or props, since we may want some action to occur when they change. Click here for more examples! . Debugging the Frontend . So generally, debugging the frontend, is very easy! . In order to see all the components, you can go into the Inspect tab / Developer Tools on your browser, you can press the F12 key or Ctrl + Shift + I. When debugging I recommend using console.log() which prints to the Console to check if your state variables and useEffect are working as intended. Next you can go to the Elements page and Inspect the components on the page. If you notice that the style you added isn’t what you expected, you can easily test out different styles in the Element tab. Finally, you can change the size of your screen and check for responsiveness! This is especially important since our website needs to be built for laptops and computers but also phones! . Disclaimer . And you’ve made it to the end!🎉 Thank you for reading up to here, I really appreciate it! . To be completely honest, I’m still learning too so please send me a message if you’re still confused or need further clarification on something! . (🤫I also didn’t test any of the code that I included on this document, so please let me know if there are any issues) . Thanks again and happy coding~ . Natalie 😊 . ",
    "url": "/pages/Onboarding/Frontend.html#writing-your-first-component",
    
    "relUrl": "/pages/Onboarding/Frontend.html#writing-your-first-component"
  },"15": {
    "doc": "Frontend",
    "title": "Frontend",
    "content": "The design of the frontend can be found here in the Figma . ",
    "url": "/pages/Project%20Architecture/Frontend.html",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html"
  },"16": {
    "doc": "Frontend",
    "title": "Components",
    "content": "All components use the standard React functional component structure and require PropTypes. Components are located in the ./client/src/components. Components are documented using storybook. You can read more about using storybook here: https://storybook.js.org/ . ",
    "url": "/pages/Project%20Architecture/Frontend.html#components",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#components"
  },"17": {
    "doc": "Frontend",
    "title": "Assets",
    "content": "Most frontend assets are located in ./client/src/assets/. This includes all icons, background art, photos. ",
    "url": "/pages/Project%20Architecture/Frontend.html#assets",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#assets"
  },"18": {
    "doc": "Frontend",
    "title": "Constants",
    "content": "Most frontend constants and information is located in ./client/src/util/. We hope to reduce the amount of frontend constants in the future. ",
    "url": "/pages/Project%20Architecture/Frontend.html#constants",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#constants"
  },"19": {
    "doc": "Frontend",
    "title": "Component Documentation",
    "content": "To view the component stories, navigate to the client directory in your terminal and run: . yarn storybook . ",
    "url": "/pages/Project%20Architecture/Frontend.html#component-documentation",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#component-documentation"
  },"20": {
    "doc": "Frontend",
    "title": "Pages",
    "content": "Pages are stored in ./client/src/util/pages.jsx. To add a page, add it to the respective category. This can modify the navigation bar, footer links, etc, as other components rely on this file. Pages are routed automatically in App.jsx, specifically the TransitionRoutes component. We use React Router DOM v6, with CSS transitions to achieve routing in React. ",
    "url": "/pages/Project%20Architecture/Frontend.html#pages",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#pages"
  },"21": {
    "doc": "Frontend",
    "title": "Snackbar Provider",
    "content": "The Snackbar provider is wrapped at the root of the app. Therefore it can be accessed by the child components. You can use setSnackbar to show a snackbar message. An example usage: . // Import useContext from React import React, { useState, useEffect, useContext } from \"react\"; // Import the context import { SnackbarContext } from \"../../util/SnackbarProvider\"; // In some component... const { setSnackbar } = useContext(SnackbarContext); // Show a snackbar message setSnackbar(\"Hello\", false); // Show an error message setSnackbar(\"Error!\", true); . ",
    "url": "/pages/Project%20Architecture/Frontend.html#snackbar-provider",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#snackbar-provider"
  },"22": {
    "doc": "Frontend",
    "title": "Darkmode Provider",
    "content": "The Darkmode provider is wrapped at the root of the app. Therefore, it can be accessed by the child components. You can use setDarkmode to show toggle the color theme. An example usage: . // Import useContext from React import React, { useState, useEffect, useContext } from \"react\"; // Import the context import { DarkModeContext } from \"../../util/DarkModeProvider\"; //In some component... const { darkMode, setDarkModeStatus } = useContext(DarkModeContext); // Toggle the theme setDarkModeStatus(false); // Check the current theme mode console.log(darkMode); . ",
    "url": "/pages/Project%20Architecture/Frontend.html#darkmode-provider",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#darkmode-provider"
  },"23": {
    "doc": "Frontend",
    "title": "Colors",
    "content": "The color list is available in /client/src/util/colors.jsx. These colors are applied using CSS variables and can be accessed in SCSS styles or inline styles. Dark mode automatically applies the respective color (index 0 - light mode, index 1 - dark mode) . ",
    "url": "/pages/Project%20Architecture/Frontend.html#colors",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#colors"
  },"24": {
    "doc": "Frontend",
    "title": "Global CSS classes",
    "content": "Note: Due to the nature of React, all CSS classes written have a global behaviour. Use specific class names for specific features on the website to not have overlapping styles. This section lists useful generic class names for quick styling. | no-link-style removed the underline from any a link (This includes the &lt;Link&gt; component) | display-only-desktop only displays the contents on a normal computer screen size, otherwise hidden | display-only-tablet only displays the contents on a tablet/phone screen size, otherwise hidden | . ",
    "url": "/pages/Project%20Architecture/Frontend.html#global-css-classes",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#global-css-classes"
  },"25": {
    "doc": "Frontend",
    "title": "SCSS Mixins",
    "content": "Import mixins into your SCSS using @import '../../scssStyles/mixins'; This allows you to use device specific selectors such as tablet. The SCSS file: ./client/src./scssStyles./_mixins.scss has more information . For example: .some-class { ... @include devices(tablet) { ... } } . ",
    "url": "/pages/Project%20Architecture/Frontend.html#scss-mixins",
    
    "relUrl": "/pages/Project%20Architecture/Frontend.html#scss-mixins"
  },"26": {
    "doc": "Git & GitHub",
    "title": "Git &amp; GitHub",
    "content": " ",
    "url": "/pages/Onboarding/GitHub.html#git--github",
    
    "relUrl": "/pages/Onboarding/GitHub.html#git--github"
  },"27": {
    "doc": "Git & GitHub",
    "title": "Table of contents",
    "content": ". | Git &amp; GitHub . | Intro to Git | Cloning GitHub Repos . | Command Prompt | GitHub Desktop | . | Git Commands | Git Feature Branches | Using Git &amp; Github in VS Code . | Changing Branches | Pulling Changes: | Making Commits | . | . | . ",
    "url": "/pages/Onboarding/GitHub.html#table-of-contents",
    
    "relUrl": "/pages/Onboarding/GitHub.html#table-of-contents"
  },"28": {
    "doc": "Git & GitHub",
    "title": "Intro to Git",
    "content": "For those that have not used Git before, Git is a type of version control which means that it tracks changes between different files, allowing many people to work on the same project together. Make sure to install git by clicking the link here! . ",
    "url": "/pages/Onboarding/GitHub.html#intro-to-git",
    
    "relUrl": "/pages/Onboarding/GitHub.html#intro-to-git"
  },"29": {
    "doc": "Git & GitHub",
    "title": "Cloning GitHub Repos",
    "content": "There are two ways to clone repositories on GitHub, either through your command prompt or using GitHub Desktop. Command Prompt . | Navigate to the code repository on GitHub, i.e., the Orientation Website repository . | Click the green Code button, and copy the HTTPS key . | Open your command prompt . | On Windows, search up cmd or Command Prompt by clicking on the Windows Key | On Mac, open the Terminal App | . | Navigate to the directory that you want to save the repository locally . | On Windows, dir into the desired folder | On Mac, cd into the desired folder | . | Enter the following git clone &lt;paste HTTPS key&gt; . | . And your repository has been cloned! You can open with your prefered IDE and start making changes! . GitHub Desktop . Before beginning make sure to download GitHub Desktop. | Navigate to the code repository on GitHub, i.e., the Orientation Website repository . | Click the green Code button, and click “Open with GitHub Desktop” . | Follow the GitHub Desktop prompts! . | . We recommend using GitHub Desktop because it’s really easy to make pull requests! A prompt would show up after you make a push and it would take you to GitHub. ",
    "url": "/pages/Onboarding/GitHub.html#cloning-github-repos",
    
    "relUrl": "/pages/Onboarding/GitHub.html#cloning-github-repos"
  },"30": {
    "doc": "Git & GitHub",
    "title": "Git Commands",
    "content": "For those that have not used much Git before, here’s a small intro with important commands! . Since you have now officially set up our Git repo locally (on your machine), any changes you make with any files will immediately be tracked. | Make sure you’re on the dev branch by typing git switch dev, and git pull into the terminal before doing anything else! By making this pull, you’re pulling all the changes from the GitHub repo to make sure that the changes on your machine are the up to date with the GitHub repository . git switch dev git pull . You need to make a new branch before you make changes to any files, but we’ll explain that later! . | Lets say you’ve make some changes to a couple of files and added some new files, and you want to push these changes to dev on GitHub . | Use git status to check on the status of your files, this will indicate Untracked files, i.e., the files that you’ve changed | You can use git add to add these untracked files. Use the period . after add to add all files, you can also specify certain files that you want to add | . git status git add . git add &lt;file path&gt; . | Once you’ve added all the untracked files, you’ll have to commit your changes before pushing these changes to GitHub. Make sure to add a commit message to describe the changes you made . git commit -m \"message describing changes you made\" . Make as many commits as you need but not too many so that each commit is a one-liner! This will help you keep track of your progress, and will help you recover changes in case you made a mistake! . | You’re ready to push these changes to GitHub! . git push . | Finally, with your new changes, you’re gonna create a pull request (PR) . | You can create a pull request through GitHub Desktop | Or you can create a pull request through GitHub on the browser! | . | . ",
    "url": "/pages/Onboarding/GitHub.html#git-commands",
    
    "relUrl": "/pages/Onboarding/GitHub.html#git-commands"
  },"31": {
    "doc": "Git & GitHub",
    "title": "Git Feature Branches",
    "content": "We mentioned before that you need to make a new branch before making changes to files. These branches allow multiple people to work on the code at once, and then after their changes are done (i.e., they’ve completed the feature that they’re working on) the code can be merged into the main branch dev! . We don’t want to work directly on the dev branch because this is what the users will see! We use branches so that we can do code reviews and test before releasing our new features! . Here are some steps before you start working on a new feature! . | Switch to the dev branch and sync (pull) the latest version git switch dev git pull . | Create a new branch based on the current branch, dev. Enter the name of your branch under branch-name. git checkout -b &lt;branch-name&gt; . Make sure to pick an appropriate name for your branch! Usually the issue#-issue-name. GitHub on the browser can also make branches for you when you navigate to the Issue &gt; Development &gt; Create a branch . | Switch to the newly created branch (if it didn’t switch automatically) . git switch &lt;branch-name&gt; . | . Some other important Git commands related to branching! . | View a list of all the branches git branch . | Delete branch, we usually delete branches after the pull request has been merged with dev. GitHub can also delete your branch after merged! git branch -d &lt;branch-name&gt; . | To pull from a specific branch git pull origin &lt;branch-name&gt; . | . ",
    "url": "/pages/Onboarding/GitHub.html#git-feature-branches",
    
    "relUrl": "/pages/Onboarding/GitHub.html#git-feature-branches"
  },"32": {
    "doc": "Git & GitHub",
    "title": "Using Git &amp; Github in VS Code",
    "content": "After cloning a repository onto your computer you can use built-in VS code tools to simplify some low level GitHub tasks. | First make sure you have the Git and GitHub extensions installed on VS code. | Open the orientation-website folder in VS code. Changing Branches . To change branches: . | click on the bottom left box . | This will open the selection bar. Here you can type the number / name of the branch you want to check out. | . Pulling Changes: . To pull changes: . | Either use the refresh icon next to the branch selection box from before . | You can also navigate to the Source Control tab on the right menu and click the synchronize button. | . Making Commits . After writing your code you can navigate to the Source Control tab and stage all your changes. You can do this by clicking on the + button next to the changes tab . ",
    "url": "/pages/Onboarding/GitHub.html#using-git--github-in-vs-code",
    
    "relUrl": "/pages/Onboarding/GitHub.html#using-git--github-in-vs-code"
  },"33": {
    "doc": "Git & GitHub",
    "title": "Git & GitHub",
    "content": " ",
    "url": "/pages/Onboarding/GitHub.html",
    
    "relUrl": "/pages/Onboarding/GitHub.html"
  },"34": {
    "doc": "Hosting & Deployment",
    "title": "Hosting &amp; Deployment",
    "content": "To get the website up and running fully on the World Wide Web you need to configure the hosting environment and deployment pipeline. For hosting needs we use DigitalOcean and our development pipeline is set up through GitHub Actions and Docker. ",
    "url": "/pages/Onboarding/Hosting.html#hosting--deployment",
    
    "relUrl": "/pages/Onboarding/Hosting.html#hosting--deployment"
  },"35": {
    "doc": "Hosting & Deployment",
    "title": "Hosting",
    "content": "Hosting on DigitalOcean can be both super simple and chaotic. If you know what to do, implementation of the hosting environment can be very straight forward. Here we’ll attempt to outline all the steps taken to get to a valid hosting environment set up on DigitalOcean. DigitalOcean Droplet . The Orientation website is hosted on a droplet with the marketplace Docker+Ubuntu image and on the Toronto servers. We used the $7/month performance level, however, we “resize” our droplet to have more processing power during heavy traffic times such as registration and the duration of F!rosh Week. This bumps it up to the $21/month subscription. Additionally, make sure to set up at least a couple SSH Keys to access your droplet. After creating the droplet you need to get a reserved IP address for it. This should be free with the purchase of the droplet. The reserved IP can be configured to point to different droplets which can be useful by letting you by pass the timely DNS change process. DNS Records . The DNS Records are owned by the Engineering Society and are managed through Google Domains. However, the orientation.skule.ca hostname has been configured to be fully managed by DigitalOcean. This helps minimize the need to communicate with the EngSoc Webmaster / Sys Admin as you can fully manage everything from DigitalOcean. However, this can be a double edged sword as you might mess up the DNS records and cause the Email service to go down for 2 days. Totally didn’t happen to me. Here is a quick overview of the DNS records in use: . | A records are used to point a hostname to an IP address. These should be configured to point to the reserved IPs from above. | MX records are used to navigate the email service. They should point to the Gmail servers. These records are standard and usually nothing will need to change. | CNAME records can be used to create an alias. Basically when you make a call to an aliased hostname it will actually go to a different one. | NS records are used to determine which servers are in charge of managing the records for a hostname. These should be pointing to the DigitalOcean nameservers to make sure that our records are valid. Nginx . | . Nginx is used to direct traffic within the DigitalOcean droplet. You can use it to ensure that different services are mapped properly. Additionally, you can use it to create a secure connection using HTTPS. The setup procedure is very simple just follow these articles written by the DigitalOcean staff. | Initial Server Setup . | How To Install Nginx . | How To Secure Nginx with Let’s Encrypt . | . The Nginx setup guide shows you how to set it up to serve static content. However we use Nginx to direct to proper ports and applications. You will be able to find the necessary Nginx config files in the deployment-environments repository. ",
    "url": "/pages/Onboarding/Hosting.html#hosting",
    
    "relUrl": "/pages/Onboarding/Hosting.html#hosting"
  },"36": {
    "doc": "Hosting & Deployment",
    "title": "Deployment",
    "content": "To deploy the project to the DigitalOcean server you will need to create production ready forms of the codebase and then upload them. To do this in a streamlined fashion we use Docker to containerize our code and then upload it to a registry on DigitalOcean. This is all done through GitHub Actions which help run all of the processes in the background. GitHub Actions . The GitHub Actions are all the files under ./github/workflows. They are configured to do things such as: . | Run tests | Deploy code to hosting | Update the GitHub Pages website | . The deployment actions create productions builds of the codebase and upload it to the Docker Registry. From there a deployment script is called to run the docker-compose commands needed to start the project. Docker Registry . The Docker Registry holds all the Docker images that are created by the GitHub actions. It is hosted by DigitalOcean and is a private registry that requires access keys to read/write to. We use the $5/month version that gives us enough space and repositories to hold all of our data. Be sure to delete older images as they will build up and fill up the storage which can use you to not be able to update the website. ",
    "url": "/pages/Onboarding/Hosting.html#deployment",
    
    "relUrl": "/pages/Onboarding/Hosting.html#deployment"
  },"37": {
    "doc": "Hosting & Deployment",
    "title": "Hosting & Deployment",
    "content": " ",
    "url": "/pages/Onboarding/Hosting.html",
    
    "relUrl": "/pages/Onboarding/Hosting.html"
  },"38": {
    "doc": "Onboarding",
    "title": "Onboarding Package",
    "content": "To make sure that you have the skills and knowledge base required to effectivity contribute to this project please complete this Onboarding Package. The following is what we believe is relevant and necessary to know. However, you might find it not to be the best learning strategy for you. In that case we highly recommend that you supplement your learning by watching these YouTube videos. ",
    "url": "/pages/Onboarding/Onboarding.html#onboarding-package",
    
    "relUrl": "/pages/Onboarding/Onboarding.html#onboarding-package"
  },"39": {
    "doc": "Onboarding",
    "title": "Onboarding",
    "content": " ",
    "url": "/pages/Onboarding/Onboarding.html",
    
    "relUrl": "/pages/Onboarding/Onboarding.html"
  },"40": {
    "doc": "Project Architecture",
    "title": "Project Architecture",
    "content": " ",
    "url": "/pages/Project%20Architecture/ProjectArchitecture.html",
    
    "relUrl": "/pages/Project%20Architecture/ProjectArchitecture.html"
  },"41": {
    "doc": "Havenger Scunt",
    "title": "Scunt",
    "content": "Scunt is broken down into 3 models: . | GameSettings | . Game settings are specified before the game begins and used for certain logic functions. For example when generating teams, the game settings are used to see how many teams are specified. The logic for if a game is running/if users can see certain information on their profile page about Scunt will be stored here. The game settings can be set on the frontend Scunt Game Settings page. You can also set the amount of starter bribe points, and the amount of leeway judges are allowed to give from the base recommended points of a mission. | Missions | . The missions are used for the objectives the frosh must complete. Usually, a spreadsheet populates this. number, name, category, points, isHidden, isJudgingStation isHidden will hide the mission from other users and can be changed anytime during a game to remove any missions requested by the faculty during the game or to release new missions during the game. isJudgingStation is a bool that indicates to the players of Scunt that they must complete the mission in front of a judge (video/photo is not accepted at the time of judging). All these flags do not have any effect on the functionality of the game apart from points. | Teams | . The teams group contains information about a team. This includes the teams nickname and amount of points. Within this collection a list of all the teams transactions can be found. For example, if a judge adds points to a team for a certain task, it is stored here. This also includes bribe points and subtraction points. The subcollection is a log of all transactions that have occurred on that team. It is usually large and only admins have access to this information. For more information and to better understand the architecture, be sure to check out the models folder and analyze the Scunt backend structure. ",
    "url": "/pages/Project%20Architecture/Scunt.html#scunt",
    
    "relUrl": "/pages/Project%20Architecture/Scunt.html#scunt"
  },"42": {
    "doc": "Havenger Scunt",
    "title": "Havenger Scunt",
    "content": " ",
    "url": "/pages/Project%20Architecture/Scunt.html",
    
    "relUrl": "/pages/Project%20Architecture/Scunt.html"
  },"43": {
    "doc": "Security",
    "title": "Security",
    "content": "This project has a lot of important pieces of information that need to be kept private. They mostly split into 2 catagories: . ",
    "url": "/pages/Onboarding/Security.html",
    
    "relUrl": "/pages/Onboarding/Security.html"
  },"44": {
    "doc": "Security",
    "title": "User Data",
    "content": "Each year over 1200 first year students trusts us with important piece of information that we must protect and keep safe. Never disclose any Frosh data to anyone and do not give access to anyone. ",
    "url": "/pages/Onboarding/Security.html#user-data",
    
    "relUrl": "/pages/Onboarding/Security.html#user-data"
  },"45": {
    "doc": "Security",
    "title": "API Keys",
    "content": "Additionally, there are a lot of services that have private API keys that we use to authenticate ourselves. These are services that can be used to imitate us and get access to our information which can lead to data exposure or financial issues. Therefor, you need to make sure to NEVER COMMIT ANYTHING THAT HAS A SECRET IN PLAIN TEXT. Incase that does happen, let the webmasters know ASAP. ",
    "url": "/pages/Onboarding/Security.html#api-keys",
    
    "relUrl": "/pages/Onboarding/Security.html#api-keys"
  },"46": {
    "doc": "Security",
    "title": "Password Manager",
    "content": "If you are able to please use a password manager to keep all the passwords that we give you. ",
    "url": "/pages/Onboarding/Security.html#password-manager",
    
    "relUrl": "/pages/Onboarding/Security.html#password-manager"
  },"47": {
    "doc": "The Team",
    "title": "The Team",
    "content": " ",
    "url": "/pages/TheTeam.html",
    
    "relUrl": "/pages/TheTeam.html"
  },"48": {
    "doc": "The Team",
    "title": "The Frosh 2T3 Web Team",
    "content": "Webmasters . | Farbod Mohammadzadeh, Natalie Chan | . Team Members . | Vraj Prajapti, Sherry Zhang, Tanushanth Thavanenthiran, Uzma Ferdous | . ",
    "url": "/pages/TheTeam.html#the-frosh-2t3-web-team",
    
    "relUrl": "/pages/TheTeam.html#the-frosh-2t3-web-team"
  },"49": {
    "doc": "The Team",
    "title": "The Frosh 2T2 Web Team",
    "content": "Webmasters . | James Kokoska, Calum Murray, Natalie Chan | . Associates . | Farbod M, Luke Yang, Neo Lou, Emily N | . External Contributors . | Matthew Wilson, Yash Vardhan, Akshat Mengi, Andrew Kim | . ",
    "url": "/pages/TheTeam.html#the-frosh-2t2-web-team",
    
    "relUrl": "/pages/TheTeam.html#the-frosh-2t2-web-team"
  },"50": {
    "doc": "Getting Started",
    "title": "Orientation Website",
    "content": ". Welcome to the University of Toronto’s Frosh engineering orientation website, used by more than 1,000 incoming students each year. This website serves as the primary platform for registering and paying for orientation events, and offers a range of features including a main schedule, announcements, a personal profile page with the ability to edit, a Scunt (scavenger hunt) game, sign-up for the Frosh retreat, QR code scanning for automated registration on event day, and more. This website is built using React, Express, Mongoose, Stripe, Docker, etc, and serves as a valuable resource for incoming students as they prepare for their first year at the University of Toronto. We hope this website helps to make the orientation process as smooth and enjoyable as possible. This repository holds the source code for UofT Engineering’s Orientation Website! This fullstack website is split into two “packages”. First, there is the frontend package, client, and second there is the backend package server. ",
    "url": "/#orientation-website",
    
    "relUrl": "/#orientation-website"
  },"51": {
    "doc": "Getting Started",
    "title": "Table of contents",
    "content": ". | Orientation Website | Getting started . | Installing yarn | Installing root dependencies | Installing frontend dependencies | Installing backend dependencies | Installing docker | . | Running the code . | Running both the frontend and the backend | Running just the frontend | Running just the backend | View all the component stories | . | . ",
    "url": "/#table-of-contents",
    
    "relUrl": "/#table-of-contents"
  },"52": {
    "doc": "Getting Started",
    "title": "Getting started",
    "content": "Note: You will need to contact a project maintainer to get access to the .env environment variables and keys. To get started, you need to install all the necessary dependencies, and then you need to install docker. This project uses yarn for dependency management, so the first step is to install yarn. Installing yarn . npm install -g yarn . After installing yarn, we are now ready to install the remaining dependencies. Installing root dependencies . First, we will install the dependencies in the root directory. To do this, navigate to the root directory of the repository in your terminal and run: . yarn install . Installing frontend dependencies . Next, we will install the frontend dependencies. To do this, navigate to the client directory in your terminal and run: . yarn install . Installing backend dependencies . Finally, we need to install the backend dependencies. To do this, navigate to the server directory in your terminal and run: . yarn install . Installing docker . The easiest way to install docker is to follow the instructions at https://www.docker.com/products/docker-desktop/ . ",
    "url": "/#getting-started",
    
    "relUrl": "/#getting-started"
  },"53": {
    "doc": "Getting Started",
    "title": "Running the code",
    "content": "When running the code, you can choose whether you want to run just the frontend, just the backend, or both at the same time. For most purposes, it is recommended to run both. Another common way to run the code is run all the stories for the frontend React components. All of these scenarios are explained below. Running both the frontend and the backend . To run both the frontend and the backend, you will need docker installed. With docker installed, navigate to the root directory of the repository, then run: . docker-compose up --build . Running just the frontend . To run just the frontend, navigate to the client directory in your terminal and run: . yarn dev . Running just the backend . To run just the backend, navigate to the server directory in your terminal and run: . yarn start:dev . View all the component stories . To view the stories, navigate to the client directory in your terminal and run: . yarn storybook . ",
    "url": "/#running-the-code",
    
    "relUrl": "/#running-the-code"
  },"54": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
